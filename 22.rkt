#lang planet neil/sicp

(define (list-append l1 l2)
  (if (null? l1)
      l2
      (cons (car l1) (list-append (cdr l1) l2))))

;;; 2.30

(define (map proc l)
  (if (null? l)
      nil
      (cons (proc (car l)) (map proc (cdr l)))))

(define (square x) (* x x))

(define (square-tree1 t)  
  (map (lambda (tree)
         (if (pair? tree)
             (square-tree1 tree)
             (square tree))) t))

(define (square-tree2 t)
  (cond ((null? t) nil)
        ((not (pair? t)) (square t))
        (else (cons (square-tree2 (car t)) (square-tree2 (cdr t))))))

;;; 2.31

(define (tree-map proc tree)
  (map (lambda (sub-tree)
         (if (pair? sub-tree)
             (tree-map proc sub-tree)
             (proc sub-tree))) tree))

(define (square-tree tree)
  (tree-map square tree))

;;; 2.32

;; Subsets of set = Subsets of subset of set without first element, "rest" +
;;                  subsets generated by appending first-element to "rest"

(define (subsets s)
  (if (null? s)
      (list nil)
      (let ((rest (subsets (cdr s))))
        (list-append rest (map (lambda (x)
                                 (list-append (list (car s)) x))
                               rest)))))

(define (test)
  (display (square-tree1 (list (list 1 2) 4 (list 5 6))))
  (newline)
  (display (square-tree2 (list (list 1 2) 4 (list 5 6))))
  (newline)
  (display (square-tree (list (list 1 2) 4 (list 5 6))))
  (newline)
  (display (subsets (list 1 2 3))))

(test)




          
             
